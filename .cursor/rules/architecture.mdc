# 架构设计规则

## 规则目的

本规则文件定义了SparkCanvas项目的架构设计原则和规范，确保系统架构的一致性、可扩展性和可维护性。

## 适用范围

- 所有模块的架构设计
- 分层架构实现
- 模块间依赖关系
- 接口设计规范

## 架构分层

### 分层结构

```
┌─────────────────────────────────────────┐
│         routers/ (API 路由层)            │  ← 处理 HTTP 请求/响应
├─────────────────────────────────────────┤
│         services/ (业务服务层)           │  ← 核心业务逻辑
├─────────────────────────────────────────┤
│    repository/ (数据访问层)              │  ← 数据库操作
│    storage/ (存储层)                     │  ← Redis/Chroma 操作
├─────────────────────────────────────────┤
│         models/ (数据模型层)             │  ← ORM 模型定义
├─────────────────────────────────────────┤
│    core/ (基础设施层)                     │  ← 配置、日志、限流
│    utils/ (工具层)                        │  ← 通用工具函数
│    middleware/ (中间件层)                 │  ← 跨切面关注点
└─────────────────────────────────────────┘
```

### 各层职责

#### 1. Routers层（路由层）

**职责：**
- HTTP请求/响应处理
- 请求参数解析和验证（Pydantic自动验证）
- 调用Service层方法
- 返回统一格式的响应

**禁止：**
- ❌ 包含业务逻辑
- ❌ 直接访问数据库
- ❌ 直接调用Repository层

**示例：**
```python
@router.post("/create", response_model=APIResponse)
async def create_prompt(
    payload: PromptCreateIn,
    current_user_id: CurrentUserId,
):
    """创建Prompt"""
    service = PromptService(repo)
    return await service.create_prompt(current_user_id, payload)
```

#### 2. Services层（业务服务层）

**职责：**
- 核心业务逻辑处理
- 权限校验和授权
- 数据转换和组装
- 调用Repository层进行数据访问
- 错误处理和异常转换

**禁止：**
- ❌ 直接操作数据库会话
- ❌ 包含HTTP相关逻辑
- ❌ 依赖路由层

**示例：**
```python
class PromptService:
    def __init__(self, repo: PromptRepository):
        self.repo = repo
    
    async def create_prompt(self, user_id: int, data: PromptCreateIn):
        # 业务逻辑
        # 权限校验
        # 调用repository
        pass
```

#### 3. Repository层（数据访问层）

**职责：**
- 数据库CRUD操作
- SQL查询构建
- 数据模型转换
- 数据库会话管理

**禁止：**
- ❌ 包含业务逻辑
- ❌ 调用Service层
- ❌ 处理HTTP相关逻辑

**示例：**
```python
class PromptRepository:
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, user_id: int, data: PromptCreateIn) -> Prompt:
        async with self.session.begin():
            prompt = Prompt(user_id=user_id, **data.model_dump())
            self.session.add(prompt)
            return prompt
```

#### 4. Models层（数据模型层）

**职责：**
- ORM模型定义
- 数据库表结构映射
- 模型关系定义
- 基础验证逻辑

**禁止：**
- ❌ 包含业务逻辑
- ❌ 依赖其他层

**示例：**
```python
class Prompt(Base):
    __tablename__ = 'prompt'
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    # ...
```

#### 5. Core层（基础设施层）

**职责：**
- 配置管理
- 日志配置
- 认证和授权
- 限流和中间件

#### 6. Utils层（工具层）

**职责：**
- 通用工具函数
- 响应格式化
- 数据验证工具
- 辅助函数

#### 7. Storage层（存储层）

**职责：**
- Redis客户端封装
- Chroma向量数据库客户端
- 会话存储管理
- 缓存操作

## 依赖方向规则

### 依赖原则

1. **单向依赖**：上层依赖下层，下层不依赖上层
2. **接口隔离**：通过接口和抽象实现层间解耦
3. **依赖注入**：通过构造函数注入依赖，而不是全局变量

### 依赖关系

```
routers → services → repository → models
    ↓        ↓
  core ← utils
    ↓
storage
```

**允许的依赖：**
- ✅ routers → services
- ✅ services → repository
- ✅ repository → models
- ✅ 所有层 → core/utils

**禁止的依赖：**
- ❌ models → repository
- ❌ repository → services
- ❌ services → routers
- ❌ models → 其他层

## 模块化设计原则

### 1. 高内聚低耦合

**高内聚：**
- 模块内部功能紧密相关
- 单一职责原则
- 模块内部修改不影响其他模块

**低耦合：**
- 模块间依赖最小化
- 通过接口通信
- 避免循环依赖

### 2. 接口隔离原则

**清晰接口：**
- 定义明确的模块接口
- 避免接口臃肿
- 按需暴露功能

**示例：**
```python
# 好的接口设计
class PromptRepository:
    async def create(...) -> Prompt: ...
    async def get_by_id(...) -> Prompt | None: ...
    async def update(...) -> Prompt: ...

# 避免：一个方法包含多个职责
```

### 3. 开闭原则

**对扩展开放：**
- 通过继承和组合扩展功能
- 支持插件机制
- 预留扩展点

**对修改关闭：**
- 核心逻辑修改最小化
- 通过配置而非代码修改行为
- 版本兼容性

## 依赖注入规范

### 数据库会话注入

```python
# dependencies.py
async def get_session() -> AsyncSession:
    session = AsyncSessionFactory()
    try:
        yield session
    finally:
        await session.close()

# router中使用
@router.post("/create")
async def create_prompt(
    session: AsyncSession = Depends(get_session),
    current_user_id: CurrentUserId,
):
    repo = PromptRepository(session)
    service = PromptService(repo)
    return await service.create_prompt(current_user_id, payload)
```

### Service依赖注入

```python
# 方式1：在router中创建
@router.post("/create")
async def create_prompt(
    session: AsyncSession = Depends(get_session),
    current_user_id: CurrentUserId,
):
    repo = PromptRepository(session)
    service = PromptService(repo)
    return await service.create_prompt(...)

# 方式2：创建依赖函数
async def get_prompt_service(
    session: AsyncSession = Depends(get_session),
) -> PromptService:
    repo = PromptRepository(session)
    return PromptService(repo)
```

## 错误处理规范

### 异常处理层次

1. **Models层**：不处理异常，直接抛出
2. **Repository层**：捕获数据库异常，转换为业务异常
3. **Service层**：处理业务异常，转换为HTTP异常
4. **Router层**：捕获HTTP异常，返回统一响应

### 异常传播

```python
# Repository层
async def get_by_id(self, prompt_id: int, user_id: int) -> Prompt | None:
    try:
        # 数据库操作
        pass
    except SQLAlchemyError as e:
        logger.error(f"数据库错误: {e}")
        raise  # 向上抛出，由Service层处理

# Service层
async def get_prompt(self, prompt_id: int, user_id: int):
    prompt = await self.repo.get_by_id(prompt_id, user_id)
    if not prompt:
        raise HTTPException(status_code=404, detail="Prompt不存在")
    if prompt.user_id != user_id:
        raise HTTPException(status_code=403, detail="无权限")
    return prompt
```

## 最佳实践

### 1. 单一职责

每个类、每个方法只负责一件事：

```python
# ✅ 好的设计
class PromptService:
    async def create_prompt(...):  # 只负责创建
    async def update_prompt(...):  # 只负责更新
    async def delete_prompt(...):  # 只负责删除

# ❌ 不好的设计
async def handle_prompt(...):  # 包含所有操作
```

### 2. 接口抽象

使用接口定义契约，便于测试和替换：

```python
from abc import ABC, abstractmethod

class IPromptRepository(ABC):
    @abstractmethod
    async def create(...) -> Prompt: ...
    
    @abstractmethod
    async def get_by_id(...) -> Prompt | None: ...
```

### 3. 配置外部化

将配置和常量外部化：

```python
# core/config.py
@dataclass
class AppConfig:
    mysql_url: str
    redis_url: str
    # ...

# 使用配置
config = load_config()
repo = PromptRepository(session, config)
```

### 4. 日志和监控

在关键位置添加日志：

```python
from core.logger import logger

async def create_prompt(...):
    logger.info(f"用户{user_id}创建Prompt: {data.name}")
    try:
        result = await self.repo.create(...)
        logger.info(f"Prompt创建成功: {result.id}")
        return result
    except Exception as e:
        logger.error(f"Prompt创建失败: {e}")
        raise
```

## 常见架构问题

### 1. 循环依赖

**问题：**
```python
# services/prompt_service.py
from repositories.user_repo import UserRepository  # 依赖repository

# repositories/user_repo.py
from services.prompt_service import PromptService  # 依赖service
```

**解决：**
- 将共享逻辑提取到utils层
- 使用依赖注入而不是直接导入
- 重新设计模块职责

### 2. 违反分层原则

**问题：**
```python
# router直接调用repository
@router.post("/create")
async def create_prompt(session: AsyncSession = Depends(get_session)):
    repo = PromptRepository(session)
    prompt = await repo.create(...)  # ❌ 跳过service层
    return prompt
```

**解决：**
- 严格遵循分层调用
- 所有业务逻辑放在service层
- Router只负责调用service

### 3. 全局状态

**问题：**
```python
# 使用全局变量
global_session = None

def get_session():
    global global_session
    if not global_session:
        global_session = create_session()
    return global_session
```

**解决：**
- 使用依赖注入
- 通过参数传递依赖
- 使用上下文管理器
